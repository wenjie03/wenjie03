---
title: javascript闭包
date: 2016-05-22 15:16:17
tags: [javascript,《你不知道的JavaScript》]
category: 术业专攻
---
> 以前看过好多文档，对于闭包不是很理解，再读《你不知道的JavaScript》上卷之后，终于明白了，感谢这本书，把自己理解的内容写下，以待学习与提升

<!-- more -->

## 观察闭包

##### 一句话说明闭包
>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行

***
##### 这是闭包吗？

`
function foo () {
  var a = 2;
  function bar () {
    console.log(a); // 2
  }
  bar();
}
foo();
`

>技术上来讲，*也许是*；但根据前面的定义，*确切地说并不是*
bar()对a的引用的方法是词法作用域的查找规则，而这些规则只是闭包的一部分。（但是非常重要的一部分！）

##### 这才是闭包！！

`
function foo () {
  var a = 2;
  function bar () {
    console.log(a); 
  }
  return bar;
}
var baz = foo();
baz();  // 2 
`
> - 函数bar() 的词法作用域能够访问foo()的内部作用域，我们将bar()函数本身当作一个值类型进行传递。
- 在这个例子中，*我们将bar所引用的函数对象本身当作返回值*
- baz函数对象调用了内部的函数bar(); bar()在自己定义的词法作用域*以外*的地方执行
- foo()执行后，foo()的整个内部作用域都被销毁，而闭包的“神奇”之处正是可以阻止这件事情的发生，事实上内部作用域**依然存在**，因此没有被回收，bar()本身在使用这个内部作用域
- bar() 依然持有对该作用域的引用，而这个引用就叫作**闭包**

**当然，无论使用何种方式对函数类型的值*进行传递*，当函数在别处被调用时都可以观察到闭包**
如：
`
function foo () {
  var a = 2;
  function baz () {
    console.log(a); //2
  }
  bar( baz );
}
function bar(fn){
  fn(); // 这就是闭包！
}
`
> -  把内部函数baz 传递给 bar，当调用这个内部函数时，它涵盖的 foo() 内部作用域的闭包就可以观察到了，因为它能够访问 a。
- 无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。

###### 为了解释如何使用闭包，以上是人为地在结构上进行了修饰，但我们写过的代码中一定到处都是闭包的身影

如：
`
function wait (message) {
  setTimeout( function timer () {
    console.log( message );
  }, 1000 )
}
wait( "Hello, closure!" );
`

将一个内部函数timer() 传递给 setTimeout()。 timer 具有涵盖 wait() 作用域的闭包，因此还保有对变量message 的引用
wait() 执行 1000 毫秒后，它的内部作用域并不会消失，timer 函数依然保有wait()作用域的闭包
*这就是闭包*

如jQuery:
`
function setupBot( name, selector ) {
  $( selector ).click( function activator() {
    console.log("activating:" + name);
  })
}
setupBot('closure Bot 1', '#bot_1');
setupBot('closure Bot 2', '#bot_2');
`
**这也是闭包**

本质上无论何时何地，如果将函数当作第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用，只要使用了回调函数，实际上就是在使用闭包

## IIFE 模式

先看一段代码
`
var a = 2;
(function IIFE(){
  console.log( a );
})()
`

这段代码可以正常工作，但严格上来说它并不是闭包，
**为什么！**
因为函数并不是在它本身的词法作用域以外执行的，它在定义时所在的作用域中执行，*a 就通过普通的词法作用域查找而非闭包被发现的！！*

> 尽管IIFE本身并不是观察闭包的恰当例子，但它的确创建了闭包，并且也是最常用来创建可以被封闭起来的闭馆的工具，因此IIFE的确同作用域息息相关，即使本身并不会真的创建作用域。

### 循环与闭包

先看下面的例子

`for (var i=1; i<=5; i++) {
  setTimeout( function timer () {
    console.log( i );
  }, i*1000);
}`

正常情况下，我们希望这段代码分别输出数字1~5，每秒一次，每次一个。
但实际上，这段代码在运行时会以每秒一次的频率输出五次6.

*这是为什么?*

6是从哪里来的，这个循环的终止条件是i 不再<=5。条件首次成立时i的值是6。输出显示的是i的最终值。

延迟函数的回调会在循环结束时才执行，根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是他们都被封闭在一个共享的全局作用域中，因些实际上只有一个i，因此会每次都输出一个6出来，

我们应该怎么做，才会每秒一次，每次一个数，分别是1~5呢？
如果在循环的过程中每个迭代都需要一个闭包作用域，会成功吗？
IIFE会通过声明并立即执行一个函数来创建作用域。那我们来试一下

`for (var i=1; i<=5; i++) {
  (function () {
    setTimeout( function timer () {
      console.log( i );
    }, i*1000);
  })();
}`

这样能行吗？**这样不行**
为什么呢？我们现在显然拥有更多的词法作用域了，的确每个延迟函数都会将IIFE在每次迭代中创建的作用域封闭起来，*如果作用域是空的* 那么仅仅将它们进行封闭是不够的，仔细看一下，我们的IIFE只是一个什么都没有的空作用域。它需要包含一点实质内容才能为我们所用。他需要有自己的变量，用来在每个迭代中储存i的值。

`for (var i=1; i<=5; i++) {
  (function (i) {
    setTimeout( function timer () {
      console.log( i );
    }, i*1000);
  })(i);
}`

现在试试，好了吗？ **好了**，在迭代内使用IIFE会为每个迭代都生成一个新的作用域，虽然都是变量i，但每个变量i都是不一样的。每个迭代中都会含有一个具有正确值的变量供我们访问

## 总结
观察模式是可以清晰的看出来闭包的，但是在实际写代码的时候，这种观察模式是很少用在实际的项目中，用到的都是IIFE或模块这类并没有明显的闭包，但实际上用到了闭包，需要我们多多的观察与思考，才会发现某中的函数记住并访问所在的词法作用域并在当前的词法作用域之外执行。

> - 本文选至*《你不知道的JavaScript》上卷*，并添加了一些个人想法。
